<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="post.css">
        <script type="text/javascript" src="postjs.js"></script>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <p>
            <img src="https://cdn-images-1.medium.com/max/1500/1*TYtiKJzWtdHZhq9TdIEICA.png" alt="image"/>
        </p>
        <br/>
        <p>Примерно год назад я начал использовать Kotlin в своих Android проектах. Мне хотелось попробовать что-то
            новое, что было бы интересно изучать. Тогда я и наткнулся на<a href="https://github.com/Kotlin/anko">
                Anko</a>. К тому времени писать UI на xml порядком осточертело. Мне всегда нравилось писать интерфейс
            руками, не прибегая к WYSIWYG и xml-разметке, используемой в Android Studio. Единственный минус заключается
            в том, что для проверки любого изменения придется перезапускать приложение. Можно использовать<a
                    href="https://plugins.jetbrains.com/plugin/7734-anko-support">плагин</a>, который показывает как
            будет выглядеть ui не запуская приложения, но мне он показался довольно странным. Так же у него есть крутая
            возможность конвертирования xml в Anko Layouts DSL.
        </p>
        <br/>
        <p>Самый большой недостаток библиотеки — практически полное отсутствие документации. Чтобы разобраться, как ее
            правильно использовать, приходилось часто заглядывать в исходники. В этой статье будет подробно разобрано
            создание приложения используя Anko Layouts и Anko Coroutines.
        </p>
        <a name="habracut"></a>
        <br/>
        <p>Сама библиотека Anko разделяется на 4 независимые части:</p>
        <br/>
        <ul>
            <li>Anko Layouts — построение UI.</li>
            <li>Anko Commons — полезные инструменты и функции.</li>
            <li>Anko SQLite — работа с базой данных SQLite.</li>
            <li>Anko Coroutines — полезные инструменты для работы с корутинами.</li>
        </ul>
        <br/>
        <p>Для добавления библиотеки в проект достаточно добавить одну строчку в зависимости проекта:</p>
        <br/>
        <p>
            <code>implementation &quot;org.jetbrains.anko:anko:$anko_version&quot;</code>
        </p>
        <br/>
        <p>где
            <code>anko_version</code>
            — текущая версия библиотеки, прописанная в build.gradle файле на project уровне:
        </p>
        <br/>
        <p>
            <code>ext.anko_version='0.10.8'</code>
        </p>
        <br/>
        <h2 id="anko-layouts">Anko Layouts</h2>
        <br/>
        <p>Anko Layouts позволяет разрабатывать UI Android приложения более эффективно, чем это было с использованием
            Java.
        </p>
        <br/>
        <p>Основным игроком на поле у нас является интерфейс
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L131">
                <code>AnkoComponent&lt;T&gt;</code>
            </a>
            с единственным методом createView, принимающим
            <a href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/AnkoContext.kt">
                <code>AnkoContext&lt;T&gt;</code>
            </a>
            и возвращающим View. Как раз в этом методе и происходит создание всего UI. Интерфейс
            <a href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/AnkoContext.kt">
                <code>AnkoContext&lt;T&gt;</code>
            </a>
            является оберткой над<a href="https://developer.android.com/reference/android/view/ViewManager&quot;">
                ViewManager</a>. Подробнее о нем будет позже.
        </p>
        <br/>
        <p>Немного разобравшись с тем, как устроен
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L131">
                <code>AnkoComponent&lt;T&gt;</code>
            </a>
            , попробуем создать простенький UI в классе нашей Activity. Стоит уточнить, что вот такое &quot;прямое&quot;
            написание UI возможно только в Activity, так как для нее написана отдельная extension функция<a
                    href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/Custom.kt#L43">
                ankoView</a>, в которой вызывается метод<a
                    href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/Internals.kt#L62">
                addView</a>, и уже в самом методе создается
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L86">
                <code>AnkoContextImpl&lt;T&gt;</code>
            </a>
            с параметром<code>setContentView = true</code>.
        </p>
        <br/>
        <pre>
            <code class="kotlin">class AppActivity : AppCompatActivity() {
                override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                verticalLayout {
                lparams(matchParent, matchParent)
                gravity = Gravity.CENTER
                textView(&quot;Cool Anko TextView&quot;) {
                gravity = Gravity.CENTER
                }
                }
                }
            </code>
        </pre>
        <br/>
        <p>Очевидно, что для чего-то большего, чем один TextView, метод onCreate быстро превратится в подобие свалки.
            Попробуем отделить класс Activity от UI. Для этого создадим еще один класс, в котором он будет описываться.
        </p>
        <br/>
        <pre>
            <code class="kotlin">class AppActivityUi: AnkoComponent&lt;AppActivity&gt; {
                override fun createView(ui: AnkoContext&lt;AppActivity&gt;): View = with(ui) {
                verticalLayout {
                lparams(matchParent, matchParent)
                gravity = Gravity.CENTER
                textView(&quot;Cool Anko TextView&quot;) {
                gravity = Gravity.CENTER
                }
                }
                }
                }
            </code>
        </pre>
        <br/>
        <p>Теперь, для того, что бы передать нашей Activity наш UI,
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L135">
                можно использовать
            </a>
        </p>
        <br/>
        <pre>
            <code class="kotlin">AppActivityUi().setContentView(this)</code>
        </pre>
        <br/>
        <p>Хорошо, но как быть, если мы хотим создать UI для фрагмента? Для этого можно использовать метод createView
            напрямую, вызывая его из onCreateView метода фрагмента. Выглядит это следующим образом:
        </p>
        <br/>
        <pre>
            <code class="kotlin">class AppFragment : Fragment() {

                override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?):
                View {
                return AppFragmentUi().createView(AnkoContext.create(requireContext(), this))
                }
                }
            </code>
        </pre>
        <br/>
        <p>Как уже было сказано —
            <a href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/AnkoContext.kt">
                <code>AnkoContext&lt;T&gt;</code>
            </a>
            является оберткой над ViewManager. У его вспомогательного объекта (companion object) есть три основных
            метода, возвращающих
            <a href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/AnkoContext.kt">
                <code>AnkoContext&lt;T&gt;</code>
            </a>
            . Разберем их поподробнее.
        </p>
        <br/>
        <h3 id="create">create</h3>
        <br/>
        <pre>
            <code class="kotlin">fun &lt;T&gt; create(ctx: Context, owner: T, setContentView: Boolean = false):
                AnkoContext&lt;T&gt;
            </code>
        </pre>
        <br/>
        <p>и его брат-близнец</p>
        <br/>
        <pre>
            <code class="kotlin">fun create(ctx: Context, setContentView: Boolean = false): AnkoContext&lt;Context&gt;
            </code>
        </pre>
        <br/>
        <p>возвращают
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L86">
                <code>AnkoContextImpl&lt;T&gt;</code>
            </a>
            .
        </p>
        <br/>
        <p>Методы используются во всех стандартных случаях, как, например, в предыдущих примерах с Activity и Fragment.
            Самым интересным здесь являются параметры owner и setContentView. Первый позволяет передать в метод
            createView instance конкретного Fragment'a, Activity или чего-либо еще.
        </p>
        <br/>
        <pre>
            <code class="kotlin">MyComponent().createView(AnkoContext.create(context, myVew))

                class MyComponent: AnkoComponent&lt;View&gt; {
                override fun createView(ui: AnkoContext&lt;View&gt;): View = with(ui) {
                val myView: View= ui.owner
                // И дальше по инструкции
                }
                }
            </code>
        </pre>
        <br/>
        <p>Второй параметр — setContentView — автоматически попробует добавить полученный view, если Context<a
                href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L110">
            является экземпляром Activity или ContextWrapper</a>. Если у него это не получится — он выкинет
            IllegalStateException.
        </p>
        <br/>
        <h3 id="createdelegate">createDelegate</h3>
        <br/>
        <p>Этот метод может быть очень полезен, однако в
            <a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts">официальной документации на гихабе</a>
            о нем нигде не написано. Наткнулся я на него в исходниках, когда решал проблему раздутия UI классов:
        </p>
        <br/>
        <pre>
            <code class="kotlin">fun &lt;T: ViewGroup&gt; createDelegate(owner: T): AnkoContext&lt;T&gt; =
                DelegatingAnkoContext(owner)
            </code>
        </pre>
        <br/>
        <p>Он позволяет добавить результат createView компонента в owner.</p>
        <br/>
        <p>Рассмотрим его использование на примере. Допустим, у нас есть большой класс, описывающий один из экранов
            приложения — AppFragmentUi.
        </p>
        <br/>
        <pre>
            <code class="kotlin">verticalLayout {
                relativeLayout {
                id = R.id.toolbar
                // тут много вложенных view
                }
                relativeLayout{
                id = R.id.content
                // тут тоже много вложенных view
                }
                }
            </code>
        </pre>
        <br/>
        <p>Логически его можно разделить на две части — на тулбар и контент, AppFragmentUiToolbar и AppFragmentUiContent
            соответственно. Тогда наш основной класс AppFragmentUi станет гораздо проще:
        </p>
        <br/>
        <pre>
            <code class="kotlin">class AppFragmentUi: AnkoComponent&lt;AppFragment&gt; {

                override fun createView(ui: AnkoContext&lt;AppFragment&gt;) = with(ui) {
                verticalLayout {
                AppFragmentUiToolbar().createView(AnkoContext.createDelegate(this))
                AppFragmentUiContent().createView(AnkoContext.createDelegate(this))
                }
                }
                }

                class AppFragmentUiToolbar : AnkoComponent&lt;_LinearLayout&gt; {
                override fun createView(ui: AnkoContext&lt;_LinearLayout&gt;): View = with(ui.owner) {
                relativeLayout {
                id = R.id.toolbar
                // тут вложенные view
                }
                }
                }
            </code>
        </pre>
        <br/>
        <p>Обратите внимание, что в функцию
            <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html">
                <code>with</code>
            </a>
            в качестве объекта передается не ui, a ui.owner.
            <br/>
            Таким образом у нас выполняется следующий алгоритм:
        </p>
        <br/>
        <ol>
            <li>Создается инстанс компонента.</li>
            <li>Метод createView создает View который будет добавлен.</li>
            <li>Полученный View добавляется в owner.</li>
        </ol>
        <br/>
        <p>Более приближенный аналог:
            <code>this.addView(AppFragmentUiToolbar().createView(...))</code>
            <br/>
            Как можно заметить, вариант с createDelegate более приятен для чтения.
        </p>
        <br/>
        <h3 id="createreusable">createReusable</h3>
        <br/>
        <p>Похоже на стандартный AnkoContext.create, но с небольшим дополнением — корневым view считается самый
            последний:
        </p>
        <br/>
        <pre>
            <code class="kotlin">class MyComponent: AnkoComponent&lt;MyObject&gt; {
                override fun createView(ui: AnkoContext&lt;MyObject&gt;): View = with(ui) {
                textView(&quot;Some text&quot;)
                // в этом моменте не будет выкинут IllegalStateException: View is already set
                // На экране будет показан &quot;Another text&quot;
                textView(&quot;Another text&quot;)
                }
                }
            </code>
        </pre>
        <br/>
        <p>В стандартной реализации, если корневой view установлен —<a
                href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L100">
            попытка установить второй view параллельно вызовет exception</a>.
        </p>
        <br/>
        <p>Метод createReusable возвращает класс<a
                href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L78">
            ReusableAnkoContext</a>, который наследуется от
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L86">
                AnkoContextImpl
            </a>
            и переопределяет метод
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/static/commons/src/main/java/AnkoContext.kt#L83">
                <code>alreadyHasView()</code>
            </a>
            .
        </p>
        <br/>
        <h3 id="customview">CustomView</h3>
        <br/>
        <p>К счастью, Anko Layouts не ограничивается лишь этим функционалом. Если нам нужно показать собственный
            CustomView, нам не придется писать
        </p>
        <br/>
        <pre>
            <code class="kotlin">verticalLayout {
                val view = CustomView(context)
                //....
                addView(view) // или addView(view.apply { ... })
                }
            </code>
        </pre>
        <br/>
        <p>Для этого можно добавлять свою обертку, которая будет делать тоже самое.</p>
        <br/>
        <p>Основным компонентов здесь выступает extension метод
            <a href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/Custom.kt">
                <code>&lt;T: View&gt;ankoView(factory: (Context) -&gt; T, theme: Int, init: T.() -&gt; Unit)</code>
            </a>
            от ViewManager, Context или Activity.
        </p>
        <br/>
        <ul>
            <li>factory — функция, на вход которой передаётся Context и возвращается View. По сути является фабрикой, в
                которой происходит создание View.
            </li>
            <li>theme — ресурс стиля, который будет применен для текущей view.</li>
            <li>init — функция, в которой для созданной View будут устанавливаться необходимые параметры.</li>
        </ul>
        <br/>
        <p>Добавим свою реализацию для нашего CustomView</p>
        <br/>
        <pre>
            <code class="kotlin">inline fun ViewManager.customView(theme: Int = 0, init: (CustomView).() -&gt; Unit):
                CustomView {
                return ankoView({ CustomView(it) }, theme, init)
                }
            </code>
        </pre>
        <br/>
        <p>Теперь наш CustomView создается очень просто:</p>
        <br/>
        <pre>
            <code class="kotlin">customView {
                id = R.id.customview
                // остальные параметры
                }
            </code>
        </pre>
        <br/>
        <p>Можно использовать lparams для применения LayoutParams к View.</p>
        <br/>
        <pre>
            <code class="kotlin">textView(&quot;text&quot;) {
                textSize = 12f
                }.lparams(width = matchParent, height = wrapContent) {
                centerInParent()
                }
            </code>
        </pre>
        <br/>
        <p>Стоит заметить, что не ко всем View это применимо — все lparams методы как правило объявляются в обертках.
            Например
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/generated/sdk28/src/main/java/Layouts.kt#L1140">
                _RelativeLayout
            </a>
            — обертка над<a href="https://developer.android.com/guide/topics/ui/layout/relative">RelativeLayout</a>. И
            так для каждого.
        </p>
        <br/>
        <p>К счастью, для Android Support Library написано несколько оберток, поэтому можно только подключить
            зависимости в gradle файле.
        </p>
        <br/>
        <pre>
            <code class="plaintext">// Appcompat-v7 (Anko Layouts)
                implementation &quot;org.jetbrains.anko:anko-appcompat-v7:$anko_version&quot;
                implementation &quot;org.jetbrains.anko:anko-coroutines:$anko_version&quot;

                // CardView-v7
                implementation &quot;org.jetbrains.anko:anko-cardview-v7:$anko_version&quot;

                // Design
                implementation &quot;org.jetbrains.anko:anko-design:$anko_version&quot;
                implementation &quot;org.jetbrains.anko:anko-design-coroutines:$anko_version&quot;

                // GridLayout-v7
                implementation &quot;org.jetbrains.anko:anko-gridlayout-v7:$anko_version&quot;

                // Percent
                implementation &quot;org.jetbrains.anko:anko-percent:$anko_version&quot;

                // RecyclerView-v7
                implementation &quot;org.jetbrains.anko:anko-recyclerview-v7:$anko_version&quot;
                implementation &quot;org.jetbrains.anko:anko-recyclerview-v7-coroutines:$anko_version&quot;

                // Support-v4 (Anko Layouts)
                implementation &quot;org.jetbrains.anko:anko-support-v4:$anko_version&quot;

                // ConstraintLayout
                implementation &quot;org.jetbrains.anko:anko-constraint-layout:$anko_version&quot;
            </code>
        </pre>
        <br/>
        <p>Помимо всего прочего, библиотека позволяет более удобную имплементацию различных listener'ов. Небольшой
            пример из репозитория:
        </p>
        <br/>
        <pre>
            <code class="kotlin">seekBar.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) = Unit
                override fun onStartTrackingTouch(seekBar: SeekBar?) = Unit
                override fun onStopTrackingTouch(seekBar: SeekBar) = Unit
                })
            </code>
        </pre>
        <br/>
        <p>и теперь используя Anko</p>
        <br/>
        <pre>
            <code class="plaintext">seekBar {
                onSeekBarChangeListener {
                onProgressChanged { seekBar, progress, fromUser -&gt;
                // do something
                }
                }
                }
            </code>
        </pre>
        <br/>
        <p>Также некоторые listener'ы поддерживают корутины:</p>
        <br/>
        <pre>
            <code class="kotlin">verticalLayout{
                val anyCoroutineContext = GlobalScope.coroutineContext
                onClick(anyCoroutineContext) {
                //this: CoroutineScope
                }
                }
            </code>
        </pre>
        <br/>
        <h2 id="anko-coroutines">Anko Coroutines</h2>
        <br/>
        <p>Для безопасной передачи чувствительных к утечкам памяти объектов используется метод<code>asReference</code>.
            Он базируется над
            <a href="https://developer.android.com/reference/java/lang/ref/WeakReference">WeakReference</a>
            и возвращает объект
            <a href="https://github.com/Kotlin/anko/blob/acb7e606dfca0ebd5becf04b93c5b932e9575246/anko/library/generated/coroutines/src/main/java/weakReferenceSupport.kt#L24">
                Ref.
            </a>
            <br/>
        <pre>
            <code class="kotlin">verticalLayout{
                val activity = ui.owner
                val activityReference: Ref&lt;AppActivity&gt; = activity.asReference()
                onClick(anyCoroutineContext) {
                ref().doSomething()
                }
                }
            </code>
        </pre>
        <br/>
        <p>Допустим, требуется в стандартный
            <a href="https://developer.android.com/reference/android/support/v4/view/ViewPager.OnPageChangeListener">
                ViewPager.OnPageChangeListener
            </a>
            добавить поддержку корутин. Сделаем его таким же крутым, как и пример с seekbar'ом.
            <br/>
            Во-первых, создаем отдельный класс и наследуемся от<a
                    href="https://developer.android.com/reference/android/support/v4/view/ViewPager.OnPageChangeListener">
                ViewPager.OnPageChangeListener</a>.
        </p>
        <br/>
        <pre>
            <code class="kotlin">class CoroutineOnPageChangeListener(
                private val coroutineContext: CoroutineContext = Dispatchers.Main
                ) : ViewPager.OnPageChangeListener {

                }
            </code>
        </pre>
        <br/>
        <p>В переменных будем хранить лямбды, которые будут вызываться<a
                href="https://developer.android.com/reference/android/support/v4/view/ViewPager.OnPageChangeListener">
            ViewPager.OnPageChangeListener</a>.
        </p>
        <br/>
        <pre>
            <code class="kotlin">private var onPageScrollStateChanged: ((Int, CoroutineContext) -&gt; Unit)? = null
                private var onPageScrolled: ((Int, Float, Int, CoroutineContext) -&gt; Unit)? = null
                private var onPageSelected: ((Int, CoroutineContext) -&gt; Unit)? = null
            </code>
        </pre>
        <br/>
        <p>Реализуем инициализацию для одной из этих переменных (остальные делаются аналогично)</p>
        <br/>
        <pre>
            <code class="kotlin">fun onPageScrollStateChanged(action: ((Int, CoroutineContext) -&gt; Unit)?) {
                onPageScrollStateChanged = action
                }
            </code>
        </pre>
        <br/>
        <p>И в конце имплементируем функцию с таким же названием.</p>
        <br/>
        <pre>
            <code class="kotlin">override fun onPageScrollStateChanged(state: Int) {
                GlobalScope.launch(coroutineContext) {
                onPageScrollStateChanged?.invoke(state, coroutineContext)
                }
                }
            </code>
        </pre>
        <br/>
        <p>Осталось добавить extension функцию, чтобы это все работало</p>
        <br/>
        <pre>
            <code class="kotlin">fun ViewPager.onPageChangeListenerCoroutines(init: CoroutineOnPageChangerListener.() -&gt;
                Unit) {
                val listener = CoroutineOnPageChangerListener()
                listener.init()
                addOnPageChangeListener(listener)
                }
            </code>
        </pre>
        <br/>
        <p>И вставляем всё это дело под ViewPager</p>
        <br/>
        <pre>
            <code class="kotlin">viewPager {
                onPageChangeListenerCoroutines {
                onPageScrolled { position, offset, pixels, coroutineContext -&gt;
                // делаем что-нибудь полезное в корутине.
                }
                }
                }
            </code>
        </pre>
        <br/>
        <div class="spoiler">
            <b class="spoiler_title"  onclick="onSpoilerClickedListener(this)">Полный код тут</b>
            <div class="spoiler_text" style="display: none; padding-left: 24px">
                <pre>
                    <code class="kotlin">class CoroutineOnPageChangeListener(
                        private val coroutineContext: CoroutineContext = Dispatchers.Main
                        ) : ViewPager.OnPageChangeListener {

                        private var onPageScrollStateChanged: ((Int, CoroutineContext) -&gt; Unit)? = null
                        private var onPageScrolled: ((Int, Float, Int, CoroutineContext) -&gt; Unit)? = null
                        private var onPageSelected: ((Int, CoroutineContext) -&gt; Unit)? = null

                        fun onPageScrollStateChanged(action: ((Int, CoroutineContext) -&gt; Unit)?) {
                        onPageScrollStateChanged = action
                        }

                        fun onPageScrolled(action: ((Int, Float, Int, CoroutineContext) -&gt; Unit)?) {
                        onPageScrolled = action
                        }

                        fun onPageSelected(action: ((Int, CoroutineContext) -&gt; Unit)?) {
                        onPageSelected = action
                        }

                        override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {
                        GlobalScope.launch(coroutineContext) {
                        onPageScrolled?.invoke(position, positionOffset, positionOffsetPixels, coroutineContext)
                        }
                        }

                        override fun onPageSelected(position: Int) {
                        GlobalScope.launch(coroutineContext) {
                        onPageSelected?.invoke(position, coroutineContext)
                        }
                        }

                        override fun onPageScrollStateChanged(state: Int) {
                        GlobalScope.launch(coroutineContext) {
                        onPageScrollStateChanged?.invoke(state, coroutineContext)
                        }
                        }
                        }

                        fun ViewPager.onPageChangeListenerCoroutines(init: CoroutineOnPageChangerListener.() -&gt; Unit)
                        {
                        val listener = CoroutineOnPageChangerListener()
                        listener.init()
                        addOnPageChangeListener(listener)
                        }
                    </code>
                </pre>
            </div>
        </div>
        <br/>
        <p>Так же в библиотеке Anko Layouts есть множество полезных методов, таких как переводы в<a
                href="https://github.com/Kotlin/anko/blob/master/anko/library/static/commons/src/main/java/Dimensions.kt">
            различные метрики</a>.
        </p>
        </p>
    </body>
</html>