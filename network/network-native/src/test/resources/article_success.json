{
  "data": {
    "id": 442440,
    "is_corporative": 0,
    "is_tutorial": false,
    "time_published": "2019-03-03T17:12:07+03:00",
    "time_interesting": "2019-03-03T22:01:00+03:00",
    "comments_count": 19,
    "score": 19,
    "votes_count": 19,
    "favorites_count": 52,
    "lang": "ru",
    "tags_string": "android, kotlin",
    "title": "Создание Android приложения с использованием Anko Layouts и Anko Coroutines",
    "preview_html": "\u003Cp\u003E\u003Cimg src=\u0022https:\/\/cdn-images-1.medium.com\/max\/1500\/1*TYtiKJzWtdHZhq9TdIEICA.png\u0022 alt=\u0022image\u0022\/\u003E\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EПримерно год назад я начал использовать Kotlin в своих Android проектах. Мне хотелось попробовать что-то новое, что было бы интересно изучать. Тогда я и наткнулся на \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\u0022\u003EAnko\u003C\/a\u003E. К тому времени писать UI на xml порядком осточертело. Мне всегда нравилось писать интерфейс руками, не прибегая к WYSIWYG и xml-разметке, используемой в Android Studio. Единственный минус заключается в том, что для проверки любого изменения придется перезапускать приложение. Можно использовать \u003Ca href=\u0022https:\/\/plugins.jetbrains.com\/plugin\/7734-anko-support\u0022\u003Eплагин\u003C\/a\u003E, который показывает как будет выглядеть ui не запуская приложения, но мне он показался довольно странным. Так же у него есть крутая возможность конвертирования xml в Anko Layouts DSL.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EСамый большой недостаток библиотеки — практически полное отсутствие документации. Чтобы разобраться, как ее правильно использовать, приходилось часто заглядывать в исходники. В этой статье будет подробно разобрано создание приложения используя Anko Layouts и Anko Coroutines.\u003C\/p\u003E",
    "text_cut": "Читать дальше \u0026rarr;",
    "text_html": "\u003Cp\u003E\u003Cimg src=\u0022https:\/\/cdn-images-1.medium.com\/max\/1500\/1*TYtiKJzWtdHZhq9TdIEICA.png\u0022 alt=\u0022image\u0022\/\u003E\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EПримерно год назад я начал использовать Kotlin в своих Android проектах. Мне хотелось попробовать что-то новое, что было бы интересно изучать. Тогда я и наткнулся на \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\u0022\u003EAnko\u003C\/a\u003E. К тому времени писать UI на xml порядком осточертело. Мне всегда нравилось писать интерфейс руками, не прибегая к WYSIWYG и xml-разметке, используемой в Android Studio. Единственный минус заключается в том, что для проверки любого изменения придется перезапускать приложение. Можно использовать \u003Ca href=\u0022https:\/\/plugins.jetbrains.com\/plugin\/7734-anko-support\u0022\u003Eплагин\u003C\/a\u003E, который показывает как будет выглядеть ui не запуская приложения, но мне он показался довольно странным. Так же у него есть крутая возможность конвертирования xml в Anko Layouts DSL.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EСамый большой недостаток библиотеки — практически полное отсутствие документации. Чтобы разобраться, как ее правильно использовать, приходилось часто заглядывать в исходники. В этой статье будет подробно разобрано создание приложения используя Anko Layouts и Anko Coroutines.\u003C\/p\u003E\u003Ca name=\u0022habracut\u0022\u003E\u003C\/a\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EСама библиотека Anko разделяется на 4 независимые части:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EAnko Layouts — построение UI.\u003C\/li\u003E\r\n\u003Cli\u003EAnko Commons — полезные инструменты и функции.\u003C\/li\u003E\r\n\u003Cli\u003EAnko SQLite — работа с базой данных SQLite.\u003C\/li\u003E\r\n\u003Cli\u003EAnko Coroutines — полезные инструменты для работы с корутинами.\u003C\/li\u003E\r\n\u003C\/ul\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EДля добавления библиотеки в проект достаточно добавить одну строчку в зависимости проекта:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003E\u003Ccode\u003Eimplementation \u0026quot;org.jetbrains.anko:anko:$anko_version\u0026quot;\u003C\/code\u003E\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003Eгде \u003Ccode\u003Eanko_version\u003C\/code\u003E — текущая версия библиотеки, прописанная в build.gradle файле на project уровне:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003E\u003Ccode\u003Eext.anko_version=\u00270.10.8\u0027\u003C\/code\u003E\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Ch2 id=\u0022anko-layouts\u0022\u003EAnko Layouts\u003C\/h2\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EAnko Layouts позволяет разрабатывать UI Android приложения более эффективно, чем это было с использованием Java. \u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОсновным игроком на поле у нас является интерфейс \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L131\u0022\u003E\u003Ccode\u003EAnkoComponent\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E с единственным методом createView, принимающим \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt\u0022\u003E\u003Ccode\u003EAnkoContext\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E и возвращающим View. Как раз в этом методе и происходит создание всего UI. Интерфейс \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt\u0022\u003E\u003Ccode\u003EAnkoContext\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E является оберткой над \u003Ca href=\u0022https:\/\/developer.android.com\/reference\/android\/view\/ViewManager\u0026quot;\u0022\u003EViewManager\u003C\/a\u003E. Подробнее о нем будет позже.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EНемного разобравшись с тем, как устроен \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L131\u0022\u003E\u003Ccode\u003EAnkoComponent\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E, попробуем создать простенький UI в классе нашей Activity. Стоит уточнить, что вот такое \u0026quot;прямое\u0026quot; написание UI возможно только в Activity, так как для нее написана отдельная extension функция \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/Custom.kt#L43\u0022\u003EankoView\u003C\/a\u003E, в которой вызывается метод \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/Internals.kt#L62\u0022\u003EaddView\u003C\/a\u003E, и уже в самом методе создается \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L86\u0022\u003E\u003Ccode\u003EAnkoContextImpl\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E с параметром \u003Ccode\u003EsetContentView = true\u003C\/code\u003E. \u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass AppActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        verticalLayout {\n            lparams(matchParent, matchParent)\n            gravity = Gravity.CENTER\n            textView(\u0026quot;Cool Anko TextView\u0026quot;) {\n                gravity = Gravity.CENTER\n            }\n        }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОчевидно, что для чего-то большего, чем один TextView, метод onCreate быстро превратится в подобие свалки. Попробуем отделить класс Activity от UI. Для этого создадим еще один класс, в котором он будет описываться.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass AppActivityUi: AnkoComponent\u0026lt;AppActivity\u0026gt; {\n    override fun createView(ui: AnkoContext\u0026lt;AppActivity\u0026gt;): View = with(ui) {\n        verticalLayout {\n            lparams(matchParent, matchParent)\n            gravity = Gravity.CENTER\n            textView(\u0026quot;Cool Anko TextView\u0026quot;) {\n                gravity = Gravity.CENTER\n            }\n        }\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EТеперь, для того, что бы передать нашей Activity наш UI, \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L135\u0022\u003Eможно использовать\u003C\/a\u003E\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EAppActivityUi().setContentView(this)\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EХорошо, но как быть, если мы хотим создать UI для фрагмента? Для этого можно использовать метод createView напрямую, вызывая его из onCreateView метода фрагмента. Выглядит это следующим образом:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass AppFragment : Fragment() {\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {\n        return AppFragmentUi().createView(AnkoContext.create(requireContext(), this))\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EКак уже было сказано — \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt\u0022\u003E\u003Ccode\u003EAnkoContext\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E является оберткой над ViewManager. У его вспомогательного объекта (companion object) есть три основных метода, возвращающих \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt\u0022\u003E\u003Ccode\u003EAnkoContext\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E. Разберем их поподробнее.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Ch3 id=\u0022create\u0022\u003Ecreate\u003C\/h3\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003E fun \u0026lt;T\u0026gt; create(ctx: Context, owner: T, setContentView: Boolean = false): AnkoContext\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003Eи его брат-близнец\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Efun create(ctx: Context, setContentView: Boolean = false): AnkoContext\u0026lt;Context\u0026gt;\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003Eвозвращают \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L86\u0022\u003E\u003Ccode\u003EAnkoContextImpl\u0026lt;T\u0026gt;\u003C\/code\u003E\u003C\/a\u003E.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EМетоды используются во всех стандартных случаях, как, например, в предыдущих примерах с Activity и Fragment. Самым интересным здесь являются параметры owner и setContentView. Первый позволяет передать в метод createView instance конкретного Fragment\u0027a, Activity или чего-либо еще.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EMyComponent().createView(AnkoContext.create(context, myVew))\n\nclass MyComponent: AnkoComponent\u0026lt;View\u0026gt; {\n    override fun createView(ui: AnkoContext\u0026lt;View\u0026gt;): View = with(ui) {\n        val myView: View= ui.owner\n        \/\/ И дальше по инструкции\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EВторой параметр — setContentView — автоматически попробует добавить полученный view, если Context \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L110\u0022\u003Eявляется экземпляром Activity или ContextWrapper\u003C\/a\u003E. Если у него это не получится — он выкинет IllegalStateException.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Ch3 id=\u0022createdelegate\u0022\u003EcreateDelegate\u003C\/h3\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EЭтот метод может быть очень полезен, однако в \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/wiki\/Anko-Layouts\u0022\u003Eофициальной документации на гихабе\u003C\/a\u003E о нем нигде не написано. Наткнулся я на него в исходниках, когда решал проблему раздутия UI классов:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Efun \u0026lt;T: ViewGroup\u0026gt; createDelegate(owner: T): AnkoContext\u0026lt;T\u0026gt; = DelegatingAnkoContext(owner)\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОн позволяет добавить результат createView компонента в owner.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EРассмотрим его использование на примере. Допустим, у нас есть большой класс, описывающий один из экранов приложения — AppFragmentUi. \u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EverticalLayout {\n    relativeLayout {\n        id = R.id.toolbar\n        \/\/ тут много вложенных view\n    }\n    relativeLayout{\n        id = R.id.content\n        \/\/ тут тоже много вложенных view\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EЛогически его можно разделить на две части — на тулбар и контент, AppFragmentUiToolbar и AppFragmentUiContent соответственно. Тогда наш основной класс AppFragmentUi станет гораздо проще:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass AppFragmentUi: AnkoComponent\u0026lt;AppFragment\u0026gt; {\n\n    override fun createView(ui: AnkoContext\u0026lt;AppFragment\u0026gt;) = with(ui) {\n        verticalLayout {\n            AppFragmentUiToolbar().createView(AnkoContext.createDelegate(this))\n            AppFragmentUiContent().createView(AnkoContext.createDelegate(this))\n        }\n    }\n}\n\nclass AppFragmentUiToolbar : AnkoComponent\u0026lt;_LinearLayout\u0026gt; {\n    override fun createView(ui: AnkoContext\u0026lt;_LinearLayout\u0026gt;): View = with(ui.owner) {\n        relativeLayout {\n            id = R.id.toolbar\n            \/\/ тут вложенные view\n        }\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОбратите внимание, что в функцию \u003Ca href=\u0022https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin\/with.html\u0022\u003E\u003Ccode\u003Ewith\u003C\/code\u003E\u003C\/a\u003E в качестве объекта передается не ui, a ui.owner.\u003Cbr\/\u003E\r\nТаким образом у нас выполняется следующий алгоритм:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EСоздается инстанс компонента.\u003C\/li\u003E\r\n\u003Cli\u003EМетод createView создает View который будет добавлен.\u003C\/li\u003E\r\n\u003Cli\u003EПолученный View добавляется в owner.\u003C\/li\u003E\r\n\u003C\/ol\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EБолее приближенный аналог: \u003Ccode\u003Ethis.addView(AppFragmentUiToolbar().createView(...))\u003C\/code\u003E\u003Cbr\/\u003E\r\nКак можно заметить, вариант с createDelegate более приятен для чтения.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Ch3 id=\u0022createreusable\u0022\u003EcreateReusable\u003C\/h3\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EПохоже на стандартный AnkoContext.create, но с небольшим дополнением — корневым view считается самый последний:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass MyComponent: AnkoComponent\u0026lt;MyObject\u0026gt; {\n    override fun createView(ui: AnkoContext\u0026lt;MyObject\u0026gt;): View = with(ui) {\n        textView(\u0026quot;Some text\u0026quot;)\n        \/\/ в этом моменте не будет выкинут IllegalStateException: View is already set \n        \/\/ На экране будет показан \u0026quot;Another text\u0026quot;\n        textView(\u0026quot;Another text\u0026quot;) \n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EВ стандартной реализации, если корневой view установлен — \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L100\u0022\u003Eпопытка установить второй view параллельно вызовет exception\u003C\/a\u003E.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EМетод createReusable возвращает класс \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L78\u0022\u003EReusableAnkoContext\u003C\/a\u003E, который наследуется от \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L86\u0022\u003EAnkoContextImpl \u003C\/a\u003E и переопределяет метод \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/static\/commons\/src\/main\/java\/AnkoContext.kt#L83\u0022\u003E\u003Ccode\u003EalreadyHasView()\u003C\/code\u003E\u003C\/a\u003E.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Ch3 id=\u0022customview\u0022\u003ECustomView\u003C\/h3\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EК счастью, Anko Layouts не ограничивается лишь этим функционалом. Если нам нужно показать собственный CustomView, нам не придется писать \u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EverticalLayout {\n    val view = CustomView(context)\n    \/\/....\n    addView(view) \/\/ или addView(view.apply { ... })\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EДля этого можно добавлять свою обертку, которая будет делать тоже самое.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОсновным компонентов здесь выступает extension метод \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/Custom.kt\u0022\u003E\u003Ccode\u003E\u0026lt;T: View\u0026gt;ankoView(factory: (Context) -\u0026gt; T, theme: Int, init: T.() -\u0026gt; Unit)\u003C\/code\u003E\u003C\/a\u003E от ViewManager, Context или Activity.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Efactory — функция, на вход которой передаётся Context и возвращается View. По сути является фабрикой, в которой происходит создание View.\u003C\/li\u003E\r\n\u003Cli\u003Etheme — ресурс стиля, который будет применен для текущей view.\u003C\/li\u003E\r\n\u003Cli\u003Einit — функция, в которой для созданной View будут устанавливаться необходимые параметры.\u003C\/li\u003E\r\n\u003C\/ul\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EДобавим свою реализацию для нашего CustomView\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Einline fun ViewManager.customView(theme: Int = 0, init: (CustomView).() -\u0026gt; Unit): CustomView {\n    return ankoView({ CustomView(it) }, theme, init)\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EТеперь наш CustomView создается очень просто:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EcustomView {\n    id = R.id.customview\n    \/\/ остальные параметры\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EМожно использовать lparams для применения LayoutParams к View.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EtextView(\u0026quot;text\u0026quot;) {\n        textSize = 12f\n    }.lparams(width = matchParent, height = wrapContent) {\n        centerInParent()\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EСтоит заметить, что не ко всем View это применимо — все lparams методы как правило объявляются в обертках. Например \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/generated\/sdk28\/src\/main\/java\/Layouts.kt#L1140\u0022\u003E_RelativeLayout\u003C\/a\u003E — обертка над \u003Ca href=\u0022https:\/\/developer.android.com\/guide\/topics\/ui\/layout\/relative\u0022\u003ERelativeLayout\u003C\/a\u003E. И так для каждого.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EК счастью, для Android Support Library написано несколько оберток, поэтому можно только подключить зависимости в gradle файле.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022plaintext\u0022\u003E    \/\/ Appcompat-v7 (Anko Layouts)\n    implementation \u0026quot;org.jetbrains.anko:anko-appcompat-v7:$anko_version\u0026quot;\n    implementation \u0026quot;org.jetbrains.anko:anko-coroutines:$anko_version\u0026quot;\n\n    \/\/ CardView-v7\n    implementation \u0026quot;org.jetbrains.anko:anko-cardview-v7:$anko_version\u0026quot;\n\n    \/\/ Design\n    implementation \u0026quot;org.jetbrains.anko:anko-design:$anko_version\u0026quot;\n    implementation \u0026quot;org.jetbrains.anko:anko-design-coroutines:$anko_version\u0026quot;\n\n    \/\/ GridLayout-v7\n    implementation \u0026quot;org.jetbrains.anko:anko-gridlayout-v7:$anko_version\u0026quot;\n\n    \/\/ Percent\n    implementation \u0026quot;org.jetbrains.anko:anko-percent:$anko_version\u0026quot;\n\n    \/\/ RecyclerView-v7\n    implementation \u0026quot;org.jetbrains.anko:anko-recyclerview-v7:$anko_version\u0026quot;\n    implementation \u0026quot;org.jetbrains.anko:anko-recyclerview-v7-coroutines:$anko_version\u0026quot;\n\n    \/\/ Support-v4 (Anko Layouts)\n    implementation \u0026quot;org.jetbrains.anko:anko-support-v4:$anko_version\u0026quot;\n\n    \/\/ ConstraintLayout\n    implementation \u0026quot;org.jetbrains.anko:anko-constraint-layout:$anko_version\u0026quot;\n\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EПомимо всего прочего, библиотека позволяет более удобную имплементацию различных listener\u0027ов. Небольшой пример из репозитория:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EseekBar.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {\n    override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) = Unit\n    override fun onStartTrackingTouch(seekBar: SeekBar?) = Unit\n    override fun onStopTrackingTouch(seekBar: SeekBar) = Unit\n})\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003Eи теперь используя Anko\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022plaintext\u0022\u003EseekBar {\n    onSeekBarChangeListener {\n        onProgressChanged { seekBar, progress, fromUser -\u0026gt;\n            \/\/ do something\n        }\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EТакже некоторые listener\u0027ы поддерживают корутины:\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003E    verticalLayout{\n    val anyCoroutineContext = GlobalScope.coroutineContext\n    onClick(anyCoroutineContext) {\n             \/\/this: CoroutineScope\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Ch2 id=\u0022anko-coroutines\u0022\u003EAnko Coroutines\u003C\/h2\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EДля безопасной передачи чувствительных к утечкам памяти объектов используется метод \u003Ccode\u003EasReference\u003C\/code\u003E. Он базируется над \u003Ca href=\u0022https:\/\/developer.android.com\/reference\/java\/lang\/ref\/WeakReference\u0022\u003EWeakReference\u003C\/a\u003E и возвращает объект \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/acb7e606dfca0ebd5becf04b93c5b932e9575246\/anko\/library\/generated\/coroutines\/src\/main\/java\/weakReferenceSupport.kt#L24\u0022\u003ERef.\u003C\/a\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EverticalLayout{\n    val activity = ui.owner\n    val activityReference: Ref\u0026lt;AppActivity\u0026gt; = activity.asReference()\n    onClick(anyCoroutineContext) {\n        ref().doSomething()\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EДопустим, требуется в стандартный \u003Ca href=\u0022https:\/\/developer.android.com\/reference\/android\/support\/v4\/view\/ViewPager.OnPageChangeListener\u0022\u003EViewPager.OnPageChangeListener\u003C\/a\u003E добавить поддержку корутин. Сделаем его таким же крутым, как и пример с seekbar\u0027ом.\u003Cbr\/\u003E\r\nВо-первых, создаем отдельный класс и наследуемся от \u003Ca href=\u0022https:\/\/developer.android.com\/reference\/android\/support\/v4\/view\/ViewPager.OnPageChangeListener\u0022\u003EViewPager.OnPageChangeListener\u003C\/a\u003E.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass CoroutineOnPageChangeListener(\n    private val coroutineContext: CoroutineContext = Dispatchers.Main\n) : ViewPager.OnPageChangeListener {\n\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EВ переменных будем хранить лямбды, которые будут вызываться \u003Ca href=\u0022https:\/\/developer.android.com\/reference\/android\/support\/v4\/view\/ViewPager.OnPageChangeListener\u0022\u003EViewPager.OnPageChangeListener\u003C\/a\u003E. \u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003E    private var onPageScrollStateChanged: ((Int, CoroutineContext) -\u0026gt; Unit)? = null\n    private var onPageScrolled: ((Int, Float, Int, CoroutineContext) -\u0026gt; Unit)? = null\n    private var onPageSelected: ((Int, CoroutineContext) -\u0026gt; Unit)? = null\n\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EРеализуем инициализацию для одной из этих переменных (остальные делаются аналогично)\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003E    fun onPageScrollStateChanged(action: ((Int, CoroutineContext) -\u0026gt; Unit)?) {\n        onPageScrollStateChanged = action\n    }\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EИ в конце имплементируем функцию с таким же названием.\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003E    override fun onPageScrollStateChanged(state: Int) {\n        GlobalScope.launch(coroutineContext) {\n            onPageScrollStateChanged?.invoke(state, coroutineContext)\n        }\n    }\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EОсталось добавить extension функцию, чтобы это все работало\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Efun ViewPager.onPageChangeListenerCoroutines(init: CoroutineOnPageChangerListener.() -\u0026gt; Unit) {\n    val listener = CoroutineOnPageChangerListener()\n    listener.init()\n    addOnPageChangeListener(listener)\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EИ вставляем всё это дело под ViewPager\u003C\/p\u003E\u003Cbr\/\u003E\r\n\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003EviewPager {\n    onPageChangeListenerCoroutines {\n        onPageScrolled { position, offset, pixels, coroutineContext -\u0026gt;\n            \/\/ делаем что-нибудь полезное в корутине.\n        }\n    }\n}\u003C\/code\u003E\u003C\/pre\u003E\u003Cbr\/\u003E\r\n\u003Cdiv class=\u0022spoiler\u0022\u003E\u003Cb class=\u0022spoiler_title\u0022\u003EПолный код тут\u003C\/b\u003E\u003Cdiv class=\u0022spoiler_text\u0022\u003E\u003Cpre\u003E\u003Ccode class=\u0022kotlin\u0022\u003Eclass CoroutineOnPageChangeListener(\n    private val coroutineContext: CoroutineContext = Dispatchers.Main\n) : ViewPager.OnPageChangeListener {\n\n    private var onPageScrollStateChanged: ((Int, CoroutineContext) -\u0026gt; Unit)? = null\n    private var onPageScrolled: ((Int, Float, Int, CoroutineContext) -\u0026gt; Unit)? = null\n    private var onPageSelected: ((Int, CoroutineContext) -\u0026gt; Unit)? = null\n\n    fun onPageScrollStateChanged(action: ((Int, CoroutineContext) -\u0026gt; Unit)?) {\n        onPageScrollStateChanged = action\n    }\n\n    fun onPageScrolled(action: ((Int, Float, Int, CoroutineContext) -\u0026gt; Unit)?) {\n        onPageScrolled = action\n    }\n\n    fun onPageSelected(action: ((Int, CoroutineContext) -\u0026gt; Unit)?) {\n        onPageSelected = action\n    }\n\n    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {\n        GlobalScope.launch(coroutineContext) {\n            onPageScrolled?.invoke(position, positionOffset, positionOffsetPixels, coroutineContext)\n        }\n    }\n\n    override fun onPageSelected(position: Int) {\n        GlobalScope.launch(coroutineContext) {\n            onPageSelected?.invoke(position, coroutineContext)\n        }\n    }\n\n    override fun onPageScrollStateChanged(state: Int) {\n        GlobalScope.launch(coroutineContext) {\n            onPageScrollStateChanged?.invoke(state, coroutineContext)\n        }\n    }\n}\n\nfun ViewPager.onPageChangeListenerCoroutines(init: CoroutineOnPageChangerListener.() -\u0026gt; Unit) {\n    val listener = CoroutineOnPageChangerListener()\n    listener.init()\n    addOnPageChangeListener(listener)\n}\n\u003C\/code\u003E\u003C\/pre\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Cbr\/\u003E\r\n\u003Cp\u003EТак же в библиотеке Anko Layouts есть множество полезных методов, таких как переводы в \u003Ca href=\u0022https:\/\/github.com\/Kotlin\/anko\/blob\/master\/anko\/library\/static\/commons\/src\/main\/java\/Dimensions.kt\u0022\u003Eразличные метрики\u003C\/a\u003E.\u003C\/p\u003E\u003C\/p\u003E",
    "is_comments_hide": 0,
    "editor_version": 1,
    "is_recovery_mode": false,
    "flows": [
      {
        "id": 1,
        "name": "Разработка",
        "alias": "develop",
        "url": "https:\/\/habr.com\/ru\/flows\/develop\/",
        "path": "\/flows\/develop\/"
      }
    ],
    "hubs": [
      {
        "id": 17107,
        "alias": "android_dev",
        "title": "Разработка под Android",
        "is_membership": false,
        "is_profiled": false,
        "is_company": false,
        "icon": "",
        "path": "hub\/android_dev\/"
      },
      {
        "id": 19441,
        "alias": "kotlin",
        "title": "Kotlin",
        "is_membership": false,
        "is_profiled": false,
        "is_company": false,
        "icon": "",
        "path": "hub\/kotlin\/"
      }
    ],
    "reading_count": 8474,
    "path": "\/post\/442440\/",
    "full_url": "https:\/\/habr.com\/ru\/post\/442440\/",
    "author": {
      "id": 1961555,
      "login": "Makentoshe",
      "time_registered": "2019-02-05T23:34:19+03:00",
      "score": 7,
      "fullname": "Хвостов Максим",
      "specializm": "Неполноценный разработчик",
      "sex": 0,
      "rating": 0,
      "contacts": [
        {
          "value": "Makentoshe",
          "title": "Github",
          "link": "\u003Ca href=\u0022https:\/\/github.com\/Makentoshe\/\u0022 class=\u0022url\u0022\u003EMakentoshe\u003C\/a\u003E"
        }
      ],
      "rating_position": 0,
      "path": "\/users\/makentoshe\/",
      "geo": {
        "country": null,
        "region": null,
        "city": null
      },
      "counters": {
        "posts": 1,
        "comments": 8,
        "followed": 1,
        "followers": 0,
        "favorites": 14
      },
      "badges": [
        {
          "id": 1,
          "title": "Захабренный",
          "alias": "habred",
          "description": "Пользователь с кармой \u003E0",
          "url": null,
          "is_removable": false,
          "is_disabled": false
        }
      ],
      "avatar": "https:\/\/habr.com\/images\/avatars\/stub-user-middle.gif",
      "is_readonly": false,
      "is_rc": false,
      "is_subscribed": false,
      "common_tags": [],
      "payment_methods": []
    },
    "has_polls": false,
    "url": "https:\/\/habr.com\/ru\/post\/442440\/",
    "post_type": 1,
    "post_type_str": "simple",
    "vote": null,
    "is_can_vote": false,
    "voting": {
      "score": 19,
      "voteCount": {
        "total": 19,
        "positive": 19,
        "negative": 0
      },
      "vote": null,
      "reasonMap": null
    },
    "is_habred": true,
    "is_interesting": true,
    "is_favorite": false,
    "comments_new": null,
    "is_can_comment": false
  },
  "server_time": "2021-02-16T19:25:41+03:00"
}