<!DOCTYPE html>
Сегодня хочу рассказать об одном случае из жизни, когда невинная ошибка при написании скрипта командной оболочки привела к удалению базы данных, используемой в продакшне. Расскажу я и о том, как
<a href="https://www.shellcheck.net/">ShellCheck
</a> (инструмент для линтинга и анализа скриптов, выходящий под лицензией GPLv3) мог бы обнаружить эту ошибку и предотвратил бы катастрофу. Да, сразу скажу, что я — автор ShellCheck.
<br>
<br>
<a href="https://habr.com/ru/company/ruvds/blog/556168/">
    <img src="https://habrastorage.org/webt/n1/ib/9q/n1ib9qllhzjiquw1l4bjig2jbbw.jpeg">
</a>
<br>
<a name="habracut"></a>
<br>
<h2>
    <font color="#3AC1EF">Происшествие</font>
</h2>
<br>Вот — описание того печального происшествия, о котором я хочу рассказать. Следующее я взял из поста на StackOverflow:
<br>
<br>
<blockquote>Наш разработчик закоммитил код с огромной ошибкой и мы нигде не можем найти нашу базу данных MongoDB.
    Пожалуйста, спасите нас!!!
    <br>
    <br>
    Он вошёл на сервер и сохранил следующий код в ~/crontab/mongod_back.sh:
    <br>
    <br>
    <pre>
        <code class="powershell">#!/bin/sh
            DUMP=mongodump
            OUT_DIR=/data/backup/mongod/tmp     // 备份文件临时目录
            TAR_DIR=/data/backup/mongod         // 备份文件正式目录
            DATE=`date +%Y_%m_%d_%H_%M_%S`      // 备份文件将以备份时间保存
            DB_USER=Guitang                     // 数据库操作员
            DB_PASS=qq____________              // 数据库操作员密码
            DAYS=14                             // 保留最新14夭的备份
            TAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot;   // 备份文件命名格式
            cd $OUT_DIR                         // 创建文件夹
            rm -rf $OUT_DIR/*                   // 清空临时目录
            mkdir -p $OUT_DIR/$DATE             // 创建本次备份文件夹
            $DUMP -d wecard -u $DB_USER -p $DB_PASS -o $OUT_DIR/$DATE  // 执行备份命令
            tar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE       // 将备份文件打包放入正式目
            find $TAR_DIR/ -mtime +%DAYS -delete             // 删除14天前的旧备洲
        </code>
    </pre>
    <br>
    А потом выполнил команду ./mongod_back.sh, после чего последовало множество сообщений об отказе в доступе. Дальше —
    он нажал Ctrl + C и сервер автоматически выключился.
    <br>
    <br>
    Потом он связался с AliCloud, инженер подключил диск к другому, работающему серверу, что позволило бы нашему
    разработчику проверить диск. Далее, он понял, что некоторые папки куда-то пропали, включая /data/, где была база
    данных MongoDB!
    <br>
    <br>
    <b>P.S.</b>
    Он не сделал снепшот диска.
</blockquote>
<br>В общем то это — кошмар для любого инженера.
<br>
<br>Анализ причин данного происшествия — это интересная задачка, для решения которой достаточно будет базовых навыков написания Shell-скриптов. Если вы хотите попытаться сами во всём разобраться — попробуйте, сейчас — самое время это сделать. А если вам нужны подсказки —
<a href="https://www.shellcheck.net/?id=rescueplease">вот</a> что выдал ShellCheck после анализа данного скрипта.
<br>
<br>Далее я в подробностях разберу этот случай и расскажу о том, как ShellCheck мог бы предотвратить катастрофу.
<br>
<br>
<h2>
    <font color="#3AC1EF">Что пошло не так?</font>
</h2>
<br>Вот — код минимального воспроизводимого примера (
<a href="https://stackoverflow.com/help/mcve">MCVE
</a>), запуск которого позволит любому всерьёз и надолго испортить себе жизнь:
<br>
<br>
<pre>
    <code class="powershell">#!/bin/sh
        DIR=/data/tmp    // Директория, которую нужно удалить
        rm -rf $DIR/*    // Удаление директории
    </code>
</pre>
<br>Тут имеется одна фатальная ошибка, которая заключается в том, что последовательность
<code>//</code> в shell-скриптах — это не комментарий. Это — путь к корневой директории, аналогичный
<code>/</code>.
<br>
<br>На некоторых платформах строка с командой
<code>rm</code> сама по себе может привести к тяжёлым последствиям, так как она сводится к
<code>rm -rf /
</code> с ещё несколькими аргументами. Правда, реализация этой команды в наши дни часто такого не позволяет. Случай, о котором я рассказал, произошёл на Ubuntu, а в ней GNU-реализация
<code>rm</code> не дала бы выполнить такую команду:
<br>
<br>
<pre>
    <code class="powershell">$ rm -rf //
        rm: it is dangerous to operate recursively on '//' (same as '/')
        rm: use --no-preserve-root to override this failsafe
    </code>
</pre>
<br>Система сообщает о том, что опасно проводить рекурсивные действия над директорией
<code>//</code> (что то же самое, что и
<code>/</code>), и предлагает, если надо, отключить эту защитную меру, с помощью опции
<code>--no-preserve-root</code>.
<br>
<br>Именно тут в игру вступает команда присвоения значения переменной.
<br>
<br>Оболочка воспринимает присвоение значения переменной и команды как две стороны одной медали. Вот что сказано об этом в стандарте
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01">POSIX</a>:
<br>
<br>
<i>
    <font color="#999999">«Простая команда» — это последовательность необязательных команд присвоения значений и
        перенаправлений, расположенных в любом порядке, за которыми, что тоже необязательно, следуют слова и
        перенаправления. Эта последовательность завершается оператором управления.
    </font>
</i>
<br>
<br>(«Простая команда» отличается от «сложной команды», которая представляет собой структуру наподобие инструкций
<code>if</code> или циклов
<code>for</code>, содержащую одну или большее количество простых или сложных команд.)
<br>
<br>Это означает, что
<code>var=42</code> и
<code>echo «Hello»
</code> — это простые команды. В первой имеется одно необязательное присвоение значения и нет необязательных слов. Во второй нет необязательных присвоений значений, но есть два необязательных слова.
<br>
<br>Это так же означает, что в состав отдельной простой команды может входить и то и другое:
<code>var=42 echo «Hello»</code>.
<br>
<br>Если не вдаваться в подробности стандарта, то окажется, что операция присвоения значения переменной в простой команде действительна только при выполнении вызванной команды. А если в простой команде нет имени команды — команда присвоения действует на уровне текущей оболочки. Последнее из вышеприведённых утверждений объясняет конструкцию
<code>var=42</code>. А вот с первым утверждением, пожалуй, стоит разобраться.
<br>
<br>Эта возможность может пригодиться в том случае, когда нужно указать значение переменной, действительное лишь при выполнении одной команды и не затрагивающее ту же переменную, существующую на уровне оболочки:
<br>
<br>
<pre>
    <code class="powershell">$ echo &quot;$PAGER&quot;  # Показать текущее значение переменной PAGER
        less

        $ PAGER=&quot;head -n 5&quot; man ascii
        ASCII(7)       Linux Programmer's Manual      ASCII(7)

        NAME
               ascii  -  ASCII character set encoded in octal,
               decimal, and hexadecimal

        $ echo &quot;$PAGER&quot;  # Текущее значение PAGER не изменилось
        less
    </code>
</pre>
<br>Именно это нечаянно и было сделано в вышеописанном случае. Так же, как в предыдущем примере новое значение
<code>PAGER</code> действовало лишь во время выполнения команды
<code>man</code>, тогда область действия
<code>DIR</code> была ограничена
<code>//</code>:
<br>
<br>
<pre>
    <code class="powershell">$ DIR=/data/tmp    // Директория, которую нужно удалить
        bash: //: Is a directory

        $ echo &quot;$DIR&quot;  # Переменная не установлена
        (эта команда ничего не выводит)
    </code>
</pre>
<br>Это значит, что конструкция
<code>rm -rf $DIR/*</code> превратилась в
<code>rm -rf /*</code> и в итоге её не отловила проверка, ориентированная на
<code>rm -rf /</code>.
<br>
<br>(А почему команда
<code>rm</code> просто не отказывалась бы выполняться и при передаче ей
<code>/*</code>? Дело в том, что она не видит конструкцию
<code>/*</code>, так как оболочка сначала раскрывает эту конструкцию и команда
<code>rm</code> видит лишь
<code>/bin /boot /dev /data</code> и так далее. Хотя
<code>rm
</code>, очевидно, может отказать пользователю и в удалении директорий первого уровня, это уже начнёт мешать правильному применению данной команды, что, в соответствии с философией Unix — тяжкий грех.)
<br>
<br>
<h2>
    <font color="#3AC1EF">Как ShellCheck мог бы помочь предотвратить эту проблему?</font>
</h2>
<br>Проанализируем в ShellCheck опасный фрагмент скрипта, который, напомню, выглядит так:
<br>
<br>
<pre>
    <code class="powershell">#!/bin/sh
        DIR=/data/tmp    // The directory to delete
        rm -rf $DIR/*    // Now delete it
    </code>
</pre>
<br>Вот что у нас получилось (
<a href="https://www.shellcheck.net/?id=rescuemcve">тут</a> можно поэкспериментировать с интерактивным примером):
<br>
<br>
<pre>
    <code class="powershell">$ shellcheck myscript

        In myscript line 2:
        DIR=/data/tmp    // The directory to delete
                         ^-- SC1127: Was this intended as a comment? Use # in sh.

        In myscript line 3:
        rm -rf $DIR/*    // Now delete it
               ^----^ SC2115: Use &quot;${var:?}&quot; to ensure this never expands to /* .
               ^--^ SC2086: Double quote to prevent globbing and word splitting.
                         ^-- SC2114: Warning: deletes a system directory.
    </code>
</pre>
<br>Мы уже обсудили две проблемы этого скрипта, своевременное обнаружение которых могло бы помочь предотвратить неприятности:
<br>
<br>
<ul>
    <li>Анализатор ShellCheck обратил внимание на то, что первая последовательность<code>//</code>, вероятно, была
        задумана как комментарий (вики-страница<a href="https://www.shellcheck.net/wiki/SC1127">SC1127</a>).
    </li>
    <li>ShellCheck указал на то, что вторая последовательность
        <code>//</code>
        приведёт к воздействию на системную директорию (вики-страница<a href="https://www.shellcheck.net/wiki/SC2114">
            SC2114</a>).
    </li>
</ul>
<br>А третье замечание программы относится к универсальным способам защиты от ошибок. И применение этого совета, даже если оставить без внимания две предыдущих рекомендации, тоже позволило бы предотвратить катастрофу:
<br>
<br>
<ul>
    <li>ShellCheck предложил использовать конструкцию вида
        <code>rm -rf ${DIR:?}/*</code>
        для того чтобы остановить выполнение команды в том случае, если переменная по любой причине будет пустой или
        неустановленной (вики-страница<a href="https://www.shellcheck.net/wiki/SC2115">SC2115</a>).
    </li>
</ul>
<br>Это свело бы на нет последствия целой плеяды ошибок, способных привести к тому, что переменная окажется пустой, включая
<code>echo /tmp | read DIR</code> (подоболочки),
<code>DIR= /tmp</code> (неправильная расстановка пробелов) и
<code>DIR=$(echo /tmp)</code> (потенциальные сбои форка или команды).
<br>
<br>
<h2>
    <font color="#3AC1EF">Итоги</font>
</h2>
<br>Shell-скрипты — это очень удобный инструмент, но при их написании можно допустить массу ошибок. Многие из ошибок, носящих синтаксический характер, которые в других языках обнаружились бы очень быстро, приведя к возникновению сбоя, в нашем случае приводят лишь к тому, что скрипты начинают вести себя неправильно. Последствия неправильного поведения скриптов могут быть практически любыми — от слегка неприятных до катастрофических. Много примеров подобных скриптов можно найти
<a href="https://mywiki.wooledge.org/BashPitfalls">здесь</a> и
<a href="https://github.com/koalaman/shellcheck#gallery-of-bad-code">здесь</a>.
<br>
<br>Если в мире есть инструменты для проверки скриптов — почему бы ими не воспользоваться? Даже если (или — даже не «если», а «когда»!) вы редко пишете shell-скрипты, вы можете установить
<a href="https://www.shellcheck.net/">shellcheck
</a>, воспользовавшись своим менеджером пакетов, а так же — установить подходящий
<a href="https://github.com/koalaman/shellcheck#how-to-use">плагин</a> для своего редактора, вроде
<a href="https://www.flycheck.org/en/latest/">Flycheck</a> (Emacs) или
<a href="https://github.com/vim-syntastic/syntastic">Syntastic
</a> (Vim) и просто, до определённого момента, обо всём этом забыть.
<br>
<br>Когда вы, после установки этих инструментов, будете писать скрипт, редактор автоматически выведет предупреждения и даст советы. Вы можете обращать внимание на сообщения о стилистических погрешностях, а можете и не обращать, но, всё равно, возможно, вам стоит поглядывать на уведомления о неожиданных ошибках и на предупреждения. Это вполне может спасти вашу базу данных.
<br>
<br>Совершали ли вы опасные ошибки при написании shell-скриптов?
<br>
<br>
<a href="https://habr.com/ru/company/ruvds/blog/557204/">
    <img src="https://habrastorage.org/webt/ty/b7/fd/tyb7fdkkt98xbfhc-jlqbuybdda.jpeg">
</a>
<br>
<a href="http://ruvds.com/ru-rub?utm_source=habr&amp;utm_medium=perevod&amp;utm_campaign=shell_skript_kotoryj_udalil_bazu_dannyx,_i_istoriya_o_tom_kak_shellcheck_mog_by_pomoch_eto_predotvratit">
    <img src="https://habrastorage.org/webt/ou/g5/kh/oug5kh6sjydt9llengsiebnp40w.png">
</a>